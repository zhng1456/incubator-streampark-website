<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-flinksql/udf/2-udf">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">User-defined Functions | Apache StreamPark (incubating)</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://streampark.apache.org//docs/flinksql/udf/2-udf"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="User-defined Functions | Apache StreamPark (incubating)"><meta data-rh="true" name="description" content="用户自定义函数(udf)是用于调用经常使用的逻辑或在查询中无法以其他方式实现的自定义逻辑的扩展功能。"><meta data-rh="true" property="og:description" content="用户自定义函数(udf)是用于调用经常使用的逻辑或在查询中无法以其他方式实现的自定义逻辑的扩展功能。"><link data-rh="true" rel="icon" href="/image/favicon.ico"><link data-rh="true" rel="canonical" href="https://streampark.apache.org//docs/flinksql/udf/2-udf"><link data-rh="true" rel="alternate" href="https://streampark.apache.org//docs/flinksql/udf/2-udf" hreflang="en"><link data-rh="true" rel="alternate" href="https://streampark.apache.org//zh-CN/docs/flinksql/udf/2-udf" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://streampark.apache.org//docs/flinksql/udf/2-udf" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Apache StreamPark (incubating) RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Apache StreamPark (incubating) Atom Feed"><link rel="stylesheet" href="/assets/css/styles.7b5b63ce.css">
<link rel="preload" href="/assets/js/runtime~main.cdf548bd.js" as="script">
<link rel="preload" href="/assets/js/main.d2f28e18.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/image/logo.png" alt="StreamPark Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/image/logo.png" alt="StreamPark Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Apache StreamPark</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/">Home</a><a href="https://github.com/apache/incubator-streampark/releases" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Download</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Document</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Community</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/foundation/policies/conduct" target="_blank" rel="noopener noreferrer" class="dropdown__link">Code of conduct</a></li><li><a class="dropdown__link" href="/community/contribution_guide/mailing_lists">Join the mailing lists</a></li><li><a class="dropdown__link" href="/community/contribution_guide/become_committer">Become A Committer</a></li><li><a class="dropdown__link" href="/community/contribution_guide/become_pmc_member">Become A PMC member</a></li><li><a class="dropdown__link" href="/community/contribution_guide/new_committer_process">New Committer Process</a></li><li><a class="dropdown__link" href="/community/contribution_guide/new_pmc_ember_process">New PMC Member Process</a></li><li><a class="dropdown__link" href="/community/submit_guide/document">Documentation Notice</a></li><li><a class="dropdown__link" href="/community/submit_guide/submit_code">Submit Code</a></li></ul></div><a class="navbar__item navbar__link" href="/team">Team</a><a class="navbar__item navbar__link" href="/user">Users</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a href="https://github.com/apache/incubator-streampark/issues/507" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">FAQ</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">ASF</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Foundation</a></li><li><a href="https://www.apache.org/licenses/" target="_blank" rel="noopener noreferrer" class="dropdown__link">License</a></li><li><a href="https://www.apache.org/events/current-event" target="_blank" rel="noopener noreferrer" class="dropdown__link">Events</a></li><li><a href="https://www.apache.org/security/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Security</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Sponsorship</a></li><li><a href="https://www.apache.org/foundation/policies/privacy.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Privacy</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Thanks</a></li></ul></div><a href="https://github.com/apache/incubator-streampark" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/docs/flinksql/udf/2-udf" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en">English</a></li><li><a href="/zh-CN/docs/flinksql/udf/2-udf" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-CN">简体中文</a></li></ul></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">What is StreamPark</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/user-guide/deployment">User guide</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/user-guide/deployment">Platform deployment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/user-guide/quick-start">Quick start</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/user-guide/development">Develop Environment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/user-guide/docker-deployment">Docker Quick Tutorial</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/user-guide/LDAP">LDAP Quick Tutorial</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/development/Programming-paradigm">Development framework</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/development/Programming-paradigm">Programming paradigm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/development/config">Project Configuration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/development/alert-conf">Alert configuration</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/connector/Kafka-Connector">DataStream Connector</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Kafka-Connector">Apache Kafka Connector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Jdbc-Connector">JDBC Connector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Clickhouse-Connector">ClickHouse Connector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Doris-Connector">Apache Doris Connector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Elasticsearch-Connector">Elasticsearch Connector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Hbase-Connector">Apache HBase Connector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Http-Connector">Http Connector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/connector/Redis-Connector">Redis Connector</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/flinksql/1-query-config">Flink Sql</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/1-query-config">Query Configuration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/2-performance-tuning">Performance Tuning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/3-read-write-hive">Read Write Hive</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/4-data-type">Data Types</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/5-example">Use Cases</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" tabindex="0" href="/docs/flinksql/syntax/1-introduce">Syntax</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/1-introduce">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/2-set">set</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/3-reset">reset</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/4-create">create</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/5-insert">insert</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/6-use">use</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/7-select">select</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/8-describe">describe</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/9-alter">alter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/10-explain">explain</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/11-drop">drop</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/12-load">load</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/13-unload">unload</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/syntax/14-show">show</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/flinksql/udf/1-introduce">Functions</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/udf/1-introduce">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/flinksql/udf/2-udf">User-defined Functions</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" tabindex="0" href="/docs/flinksql/format/1-introduce">Format</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/1-introduce">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/2-csv">CSV</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/3-json">JSON</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/4-avro">AVRO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/5-confluent-avro">Confluent Avro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/6-debezium">Debezium</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/7-canal">Canal</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/8-maxwell">Maxwell</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/9-ogg">Ogg</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/10-parquet">Parquet</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/11-orc">Orc</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/format/12-raw">Raw</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" tabindex="0" href="/docs/flinksql/connector/1-introduce">Connector</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/1-introduce">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/2-kafka">Kafka</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/3-upsert-kafka">Upsert Kafka</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/4-jdbc">JDBC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/5-elasticsearch">Elasticsearch</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/6-file-system">FileSystem</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/7-hbase">Hbase</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/8-data-gen">DataGen</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/9-print">Print</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flinksql/connector/10-black-hole">BlackHole</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/advanced/">Advanced extensions</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/flink-k8s/k8s-dev">Deployment</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flink-k8s/k8s-dev">Flink on K8s </a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flink-k8s/k8s-pvc-integration">Kubernetes PVC Resource usage</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flink-k8s/hadoop-resource-integration">Hadoop resource integration</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Flink Sql</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Functions</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">User-defined Functions</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>User-defined Functions</h1></header><p>用户自定义函数(udf)是用于调用经常使用的逻辑或在查询中无法以其他方式实现的自定义逻辑的扩展功能。</p><p>用户自定义函数可以用JVM语言(如Java或Scala)或Python实现。实现者可以在UDF中使用任意的第三方库。
本章将重点介绍基于jvm的语言，请参阅PyFlink文档，了解用Python编写通用udf的详细信息。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="概述">概述<a class="hash-link" href="#概述" title="Direct link to heading">​</a></h2><p>目前，Flink区分了以下几种函数:</p><ul><li>标量函数：将标量值映射到一个新的标量值。</li><li>表函数：将标量值映射到新行，新行数据可以有多个字段。</li><li>聚合函数：将多行标量值映射为新的标量值。</li><li>表聚合函数：将多行标量值映射到新行，新行数据可以有多个字段。</li><li>异步表值函数：是用于执行查找表源的特殊函数。</li></ul><p>下面的示例展示了如何创建一个简单的标量函数，以及如何在Table API和SQL中调用该函数。</p><p>对于SQL查询，函数必须使用特定名称注册之后才能使用。对于Table API，函数可以注册或直接内联使用。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import static org.apache.flink.table.api.Expressions.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class SubstringFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public String eval(String s, Integer begin, Integer end) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return s.substring(begin, end);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class UseFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在table api中使用不注册的内联方式调用函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.from(&quot;MyTable&quot;).select(call(SubstringFunction.class, $(&quot;myField&quot;), 5, 12));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 注册函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.createTemporarySystemFunction(&quot;SubstringFunction&quot;, SubstringFunction.class);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在table api中调用注册过的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.from(&quot;MyTable&quot;).select(call(&quot;SubstringFunction&quot;, $(&quot;myField&quot;), 5, 12));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在SQL中调用注册过的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.sqlQuery(&quot;SELECT SubstringFunction(myField, 5, 12) FROM MyTable&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于交互式会话，也可以在使用或注册函数之前对它们进行参数化。在这种情况下，可以将函数实例而不是函数类用作临时函数。</p><p>它要求参数是可序列化的，以便将函数实例传递到集群。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import static org.apache.flink.table.api.Expressions.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 定义可参数化函数逻辑</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class SubstringFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    private boolean endInclusive;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public SubstringFunction(boolean endInclusive) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        this.endInclusive = endInclusive;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public String eval(String s, Integer begin, Integer end) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return s.substring(begin, endInclusive ? end + 1 : end);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class UseFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        //在table api中使用不注册的内联方式调用函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.from(&quot;MyTable&quot;).select(call(new SubstringFunction(true), $(&quot;myField&quot;), 5, 12));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        //注册函数，直接传递初始化参数，而不是在调用时传递</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.createTemporarySystemFunction(&quot;SubstringFunction&quot;, new SubstringFunction(true));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>从1.14.x开始支持以下语法：</strong></p><p>可以使用星号 <code>*</code> 作为函数调用的参数，在Table API中充当通配符，表示表中的所有列都将被传递给函数对应的位置。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import static org.apache.flink.table.api.Expressions.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public static class MyConcatFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public String eval(@DataTypeHint(inputGroup = InputGroup.ANY) Object... fields) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return Arrays.stream(fields)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .map(Object::toString)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .collect(Collectors.joining(&quot;,&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class UseFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 使用 $(&quot;*&quot;) 来调用函数，如果 MyTable 有三个字段 (a, b, c), 则这三个所有的字段都将传递给 MyConcatFunction。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.from(&quot;MyTable&quot;).select(call(MyConcatFunction.class, $(&quot;*&quot;)));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 上述做法和下面这种显式的指定所有的字段有相同的效果。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.from(&quot;MyTable&quot;).select(call(MyConcatFunction.class, $(&quot;a&quot;), $(&quot;b&quot;), $(&quot;c&quot;)));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="实现步骤">实现步骤<a class="hash-link" href="#实现步骤" title="Direct link to heading">​</a></h2><p>不管是实现哪种自定义函数，所有用户自定义的函数都遵循一些基本的实现原则。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="函数类">函数类<a class="hash-link" href="#函数类" title="Direct link to heading">​</a></h3><p>实现类必须继承于可用的基类(例如<code>org.apache.flink.table.functions.ScalarFunction</code>)。</p><p>类必须声明为公有的，而不是抽象的，并且是全局可访问的。因此，不允许使用非静态的内部类或匿名类。</p><p>为了在持久catalog中存储用户自定义函数，类必须具有默认构造函数，并且在运行时必须是可实例化的。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="evaluation方法">evaluation方法<a class="hash-link" href="#evaluation方法" title="Direct link to heading">​</a></h3><p>基类提供了一组可以被重写的方法，如<strong>open()</strong>、<strong>close()</strong>或<strong>isDeterministic()</strong>。</p><p>但是，除了那些声明的方法外，对于每条传入数据的主要处理逻辑必须通过专门的方法去实现。</p><p>根据函数类型的不同，代码生成的操作符会在运行时调用<strong>eval()</strong>、<strong>accumulate()</strong>或<strong>retract()</strong>等求值方法。</p><p>这些方法必须声明为公有，并接受一组定义好的参数。</p><p>常规JVM方法定义在这儿也适用。因此可以：</p><ul><li>实现重载方法，如<code>eval(Integer)</code>和<code>eval(LocalDateTime)</code>，</li><li>使用可变参数，如<code>eval(Integer...)</code>，</li><li>使用对象继承，如<code>eval(object)</code>，同时接受<code>LocalDateTime</code>和<code>Integer</code>，</li><li>可变参数加对象继承<code>eval(Object...)</code>，接受各种参数。</li></ul><p>如果想在Scala中实现函数，请添加<code>Scala.annotation.varargs</code>注释来处理变量参数。此外，建议使用包装类(例如<strong>java.lang.Integer</strong>而不是<code>Int</code>)来支持<code>NULL</code>。</p><p>下面的代码片段显示了重载函数的示例：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">//重载eval这个方法</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class SumFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer eval(Integer a, Integer b) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return a + b;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer eval(String a, String b) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return Integer.parseInt(a) + Integer.parseInt(b);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer eval(Double... d) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        double result = 0;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        for (double value : d)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            result += value;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return (int) result;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="类型推断">类型推断<a class="hash-link" href="#类型推断" title="Direct link to heading">​</a></h3><p>表生态系统(类似于SQL标准)是一个强类型API。因此，函数参数和返回类型都必须映射到之前章节中提到的数据类型。</p><p>从逻辑的角度来看，开发人员需要关于预期类型、精度和规模信息。从JVM的角度来看，规划器需要关于调用用户定义函数时如何将内部数据结构表示为JVM对象的信息。</p><p>验证输入参数以及为参数和函数结果派生数据类型的逻辑在类型推断中实现。</p><p>Flink的用户自定义函数实现了一个自动类型推断提取，通过反射从函数的类及其估值方法派生数据类型。
如果这种隐式反射提取方法没有成功，可以通过使用<code>@DataTypeHint</code>和<code>@FunctionHint</code>注解来改变的参数、类或方法来支持提取过程。下面展示了更多关于如何适用注解的示例。
如果需要更高级的类型推断逻辑，实现者可以在每个用户自定义函数中显式覆盖<code>getTypeInference()</code>方法。推荐使用注解方式，因为它会将自定义类型推断逻辑保持在受影响的位置附近，然后回退到默认行为，并不会影响其余的实现。</p><p><strong>自动类型推断</strong></p><p>自动类型推断会检查函数的类和计算方法，以派生函数的参数和结果的数据类型。<code>@DataTypeHint</code>和@<code>FunctionHint</code>注释支持自动提取。</p><p>有关可以隐式映射到数据类型的完整类列表，请参阅<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/table/types/#data-type-extraction" target="_blank" rel="noopener noreferrer">数据类型提取部分</a>
。</p><p><strong>@DataTypeHint</strong></p><p>在许多场景中，需要支持函数的参数和返回值类型的自动内联提取。</p><p>下面的示例演示如何使用数据类型提示。更多信息可以在注解类的文档中找到。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.annotation.DataTypeHint;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.annotation.InputGroup;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.types.Row;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">//重载eval这个方法</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class OverloadedFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    // 没有类型提示</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Long eval(long a, long b) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return a + b;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    // 指定小数的长度和精度</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public @DataTypeHint(&quot;DECIMAL(12, 3)&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    BigDecimal eval(double a, double b) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return BigDecimal.valueOf(a + b);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    // 定义一个嵌套数据类型</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @DataTypeHint(&quot;ROW&lt;s STRING, t TIMESTAMP_LTZ(3)&gt;&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Row eval(int i) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return Row.of(String.valueOf(i), Instant.ofEpochSecond(i));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    // 允许任何输入和自定义的序列化输出</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @DataTypeHint(value = &quot;RAW&quot;, bridgedTo = ByteBuffer.class)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public ByteBuffer eval(@DataTypeHint(inputGroup = InputGroup.ANY) Object o) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return MyUtils.serializeToByteBuffer(o);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>@FunctionHint</strong></p><p>在某些场景中，一个求值方法可以同时处理多个不同的数据类型。而且，在某些情况下，如果重载的求值方法有一个公共的结果类型，则应该只声明一次。</p><p><code>@FunctionHint</code>注解可以提供从参数数据类型到结果数据类型的映射。它支持为输入、累加器和结果数据类型注解整个函数类或求值方法（相当于这些类型的公共注解）。
可以在类上声明一个或多个注解，也可以为重载函数签名的每个求值方法单独声明一个或多个注解。所有提示参数都是可选的。如果未定义参数，则使用默认的基于反射的提取。所有计算方法都继承于在函数类上定义的提示参数。</p><p>下面的示例演示如何使用函数提示。更多信息可以在注解类的文档中找到。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.annotation.DataTypeHint;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.annotation.FunctionHint;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.TableFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.types.Row;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 重载eval方法，使用全局定义的输出类型</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">@FunctionHint(output = @DataTypeHint(&quot;ROW&lt;s STRING, i INT&gt;&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class OverloadedFunction extends TableFunction&lt;Row&gt; {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void eval(int a, int b) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        collect(Row.of(&quot;Sum&quot;, a + b));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void eval() {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        collect(Row.of(&quot;Empty args&quot;, -1));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 将类型推断和求值方法解耦，将类型推断交给函数提示</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">@FunctionHint(input = {@DataTypeHint(&quot;INT&quot;), @DataTypeHint(&quot;INT&quot;)}, output = @DataTypeHint(&quot;INT&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">@FunctionHint(input = {@DataTypeHint(&quot;BIGINT&quot;), @DataTypeHint(&quot;BIGINT&quot;)}, output = @DataTypeHint(&quot;BIGINT&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">@FunctionHint(input = {}, output = @DataTypeHint(&quot;BOOLEAN&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">@FunctionHint(output = @DataTypeHint(&quot;ROW&lt;s STRING, i INT&gt;&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class OverloadedFunction extends TableFunction&lt;Object&gt; {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    // 实现只需要确定方法可以被JVM调用即可</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void eval(Object... o) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (o.length == 0) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            collect(false);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        collect(o[0]);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="自定义类型推断">自定义类型推断<a class="hash-link" href="#自定义类型推断" title="Direct link to heading">​</a></h3><p>对于大多数场景，<code>@DataTypeHint</code>和<code>@FunctionHint</code>应该足以满足用户自定义的函数建模。然而，通过重写<code>getTypeInference()</code>中定义的自动类型推断，实现者可以创建类似内置系统函数的任意函数。</p><p>下面用Java实现的示例说明自定义类型推理逻辑的潜力。它使用字符串字面值参数来确定函数的结果类型。该函数接收两个字符串参数:第一个参数表示要解析的字符串，第二个参数表示目标类型。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.DataTypes;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.catalog.DataTypeFactory;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.types.inference.TypeInference;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.types.Row;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class LiteralFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Object eval(String s, String type) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return switch (type) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            case &quot;INT&quot; -&gt; Integer.valueOf(s);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            case &quot;DOUBLE&quot; -&gt; Double.valueOf(s);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            case &quot;STRING&quot;, default -&gt; s;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    // 通过下面的逻辑代替自动基于反射的类型推断</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public TypeInference getTypeInference(DataTypeFactory typeFactory) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return TypeInference.newBuilder()</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                // 指定类型参数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                //如果需要的haunt，参数将会被隐式转化为这些类型</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .typedArguments(DataTypes.STRING(), DataTypes.STRING())</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                // 指定函数的结果类型策略</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .outputTypeStrategy(callContext -&gt; {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                    if (!callContext.isArgumentLiteral(1) || callContext.isArgumentNull(1)) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        throw callContext.newValidationError(&quot;Literal expected for second argument.&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                    // 返回基于字面量的数据类型</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                    final String literal = callContext.getArgumentValue(1, String.class).orElse(&quot;STRING&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                    return switch (literal) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        case &quot;INT&quot; -&gt; Optional.of(DataTypes.INT().notNull());</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        case &quot;DOUBLE&quot; -&gt; Optional.of(DataTypes.DOUBLE().notNull());</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        case &quot;STRING&quot;, default -&gt; Optional.of(DataTypes.STRING());</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                    };</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                })</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>有关自定义类型推断的更多示例，请参见带有
<a href="https://github.com/apache/flink/blob/release-1.13/flink-examples/flink-examples-table/src/main/java/org/apache/flink/table/examples/java/functions/AdvancedFunctionsExample.java" target="_blank" rel="noopener noreferrer">高级函数实现</a>
的flink-examples-table模块。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="确定性结果">确定性结果<a class="hash-link" href="#确定性结果" title="Direct link to heading">​</a></h3><p>每个用户自定义的函数类都可以通过重写<code>isDeterministic()</code>方法声明它是否产生确定性结果。如果函数不是纯函数(如<code>random()</code>、<code>date()</code>或<code>now()</code>)，则该方法必须返回false。
默认情况下，<code>isDeterministic()</code>返回true。</p><p>确定性结果解释：像<code>random()</code>等函数，由于在SQL中调用函数时，每行数据都会调用一次函数，如果<code>isDeterministic()</code>方法返回false，则每次调用这类函数，都会产生一个新的结果，
也就是说，函数内部逻辑必走一次；如果<code>isDeterministic()</code>方法返回<code>true</code>，该函数则会预先执行一次，然后集群运行SQL时会直接使用预先执行后的结果，而不是每行数据都调用一次这个函数。
如果函数将数据列作为参数，每行数据都会执行一次函数，因为数据列的值对函数来说是不确定的。上述讨论的是无数据行列参数的函数。</p><p>此外，<code>isDeterministic()</code>方法还可能影响运行时行为。函数可能会在两个不同的阶段被调用：</p><ol><li>在规划期间(即预运行阶段)：如果一个函数通过常量表达式调用，或者可以从给定的语句派生出常量表达式，则该函数将被预先执行求出结果值以减少常量表达式的运行次数，并且可能不再在集群上执行该函数。
除非使用<code>isDeterministic()</code>来禁用常量表达式的这种缩减特性。
例如，在规划时对ABS的调用如下：<code>SELECT ABS(-1) FROM t</code> 和 <code>SELECT ABS(field) FROM t WHERE field = -1</code>;而<code>SELECT ABS(field) FROM t</code>
则不是常量表达式。</li><li>在运行时(即集群执行)：如果一个函数被非常量表达式调用或<code>isDeterministic()</code>返回<code>false</code>。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="运行时集成方法">运行时集成方法<a class="hash-link" href="#运行时集成方法" title="Direct link to heading">​</a></h3><p>有时候，用户自定义的函数可能需要在实际工作之前获取全局运行时信息或做一些设置/清理工作。</p><p>用户自定义函数提供了可以被重写的<strong>open()</strong>和<strong>close()</strong>方法，并提供了与DataStream API的RichFunction中的方法类似的方法。</p><p><strong>open()</strong>方法在求值方法之前调用一次，最后一次调用求值方法之后调用<strong>close()</strong>方法。</p><p><strong>open()</strong>方法提供了一个<code>FunctionContext</code>，它包含了有关用户定义函数执行的上下文的信息，例如度量组（MetricGroup）数据、分布式缓存文件或全局作业参数。</p><p>通过调用FunctionContext的相应方法可以获得以下信息：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getMetricGroup()</td><td align="left">子任务的度量组信息</td></tr><tr><td align="left">getCachedFile(name)</td><td align="left">本地临时文件拷贝到分布式的缓存文件</td></tr><tr><td align="left">getJobParameter(name, defaultValue)</td><td align="left">对应key的全局作业参数值</td></tr><tr><td align="left">getExternalResourceInfos(resourceName)</td><td align="left">返回对应key的外部资源信息集合</td></tr></tbody></table><p>取决于函数执行的上下文，并非所有上述方法都可用。例如，在减少常量表达式期间，添加指标是一个无需执行的操作。</p><p>下面的示例片段展示了如何在标量函数中使用<code>FunctionContext</code>来访问全局作业参数：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.FunctionContext;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class HashCodeFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    private int factor = 0;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void open(FunctionContext context) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 访问全局参数“hashcode_factor”的值，如果参数不存在，则“12”为其默认值</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        factor = Integer.parseInt(context.getJobParameter(&quot;hashcode_factor&quot;, &quot;12&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public int eval(String s) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return s.hashCode() * factor;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class UseFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 添加作业参数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.getConfig().addJobParameter(&quot;hashcode_factor&quot;, &quot;31&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 注册函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.createTemporarySystemFunction(&quot;hashCode&quot;, HashCodeFunction.class);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 调用自定义函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.sqlQuery(&quot;SELECT myField, hashCode(myField) FROM MyTable&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="标量函数">标量函数<a class="hash-link" href="#标量函数" title="Direct link to heading">​</a></h2><p>用户自定义的标量函数会将零、一个或多个标量值映射到一个新的标量值。
<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/table/types/" target="_blank" rel="noopener noreferrer">数据类型</a>
部分中列出的任何数据类型都可以用作求值方法的参数或返回类型。</p><p>为了自定义一个标量函数，必须扩展<code>org.apache. fleck .table.functions</code>中的基类<code>ScalarFunction</code>，并实现一个或多个名为<code>eval(...)</code>的求值方法。</p><p>下面的示例演示如何定义自己的哈希码函数并在查询中调用它。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.annotation.InputGroup;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.ScalarFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import static org.apache.flink.table.api.Expressions.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class HashFunction extends ScalarFunction {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    // 允许输入任何类型数据，然后返回INT类型</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public int eval(@DataTypeHint(inputGroup = InputGroup.ANY) Object o) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return o.hashCode();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class UseFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中通过内联方式调用未注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.from(&quot;MyTable&quot;).select(call(HashFunction.class, $(&quot;myField&quot;)));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 注册函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.createTemporarySystemFunction(&quot;HashFunction&quot;, HashFunction.class);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中调用注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.from(&quot;MyTable&quot;).select(call(&quot;HashFunction&quot;, $(&quot;myField&quot;)));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在SQL中调用注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.sqlQuery(&quot;SELECT HashFunction(myField) FROM MyTable&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="表函数">表函数<a class="hash-link" href="#表函数" title="Direct link to heading">​</a></h2><p>与用户自定义的标量函数类似，用户自定义的表函数(UDTF)接受零个、一个或多个标量值作为输入参数。但是，它可以返回任意数量的行(或结构化类型)作为输出，而不是单个值。
返回的记录可以由一个或多个字段组成。如果输出记录只包含一个字段，则可以省略结构化数据，并且可以发出一个标量值，该标量值将由运行时隐式包装到row中。</p><p>为了定义表函数，必须扩展<code>org.apache.flink.table.functions</code>中的基类<code>TableFunction</code>，并实现一个或多个名为<code>eval(...)</code>的求值方法。</p><p>与其他函数类似，使用反射自动提取输入和输出数据类型，包括用于确定输出数据类型的泛型参数T。与标量函数不同，求值方法本身不能有返回类型，
相反，表函数提供了一个<code>collect(T)</code>方法，可以在每个求值方法中调用该方法，以发出零条、一条或多条记录。</p><p>在Table API中，通过.joinLateral(...) 或 .leftOuterJoinLateral(...)使用表函数。
joinLateral操作符(cross)将外部表(操作符左侧的表)中的每一行与表函数(操作符右侧的表函数)产生的所有行连接起来。
leftOuterJoinLateral操作符将来自外部表(操作符左边的表)的每一行与表值函数(操作符右边的表值函数)产生的所有行连接起来，并保留表函数返回空表的外部行。</p><p>在SQL中，使用带有<code>JOIN</code>的<code>LATERAL TABLE(&lt;TableFunction&gt;)</code>或带有<code>ON TRUE</code>连接条件的<code>LEFT JOIN</code>。</p><p>下面的示例演示如何定义自己的split函数并在查询中调用它。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.annotation.DataTypeHint;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.annotation.FunctionHint;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.TableFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.types.Row;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import static org.apache.flink.table.api.Expressions.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">@FunctionHint(output = @DataTypeHint(&quot;ROW&lt;word STRING, length INT&gt;&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class SplitFunction extends TableFunction&lt;Row&gt; {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void eval(String str) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        for (String s : str.split(&quot; &quot;)) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            // 使用collect(...)方法发出row类型数据</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            collect(Row.of(s, s.length()));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class UseFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中通过内联方式调用未注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .joinLateral(call(SplitFunction.class, $(&quot;myField&quot;)))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .leftOuterJoinLateral(call(SplitFunction.class, $(&quot;myField&quot;)))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中重命名函数的属性名</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .leftOuterJoinLateral(call(SplitFunction.class, $(&quot;myField&quot;)).as(&quot;newWord&quot;, &quot;newLength&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;newWord&quot;), $(&quot;newLength&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        //注册函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.createTemporarySystemFunction(&quot;SplitFunction&quot;, SplitFunction.class);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中调用注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .joinLateral(call(&quot;SplitFunction&quot;, $(&quot;myField&quot;)))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .leftOuterJoinLateral(call(&quot;SplitFunction&quot;, $(&quot;myField&quot;)))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在SQL中调用注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.sqlQuery(</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                &quot;SELECT myField, word, length &quot; +</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        &quot;FROM MyTable, LATERAL TABLE(SplitFunction(myField))&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.sqlQuery(</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                &quot;SELECT myField, word, length &quot; +</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        &quot;FROM MyTable &quot; +</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        &quot;LEFT JOIN LATERAL TABLE(SplitFunction(myField)) ON TRUE&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在SQL中重命名属性值</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.sqlQuery(</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                &quot;SELECT myField, newWord, newLength &quot; +</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        &quot;FROM MyTable &quot; +</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                        &quot;LEFT JOIN LATERAL TABLE(SplitFunction(myField)) AS T(newWord, newLength) ON TRUE&quot;);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果想在Scala中实现函数，不要将表函数实现为<code>Scala Object</code>。<code>Scala Object</code>是单例的，会导致并发问题。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="聚合函数">聚合函数<a class="hash-link" href="#聚合函数" title="Direct link to heading">​</a></h2><p>用户自定义的聚合函数(UDAGG)可以将多行标量值映射到一个新的标量值。</p><p>聚合函数会使用到累加器。累加器是一种中间数据结构，用于存储聚合值，直到计算出最终聚合结果。</p><p>对于每一组需要聚合的行，运行时将通过调用<code>createAccumulator()</code>方法创建一个空的累加器。随后，对每个输入行调用<code>accumulate(...)</code>方法来更新累加器。
处理完所有行后，调用<code>getValue(...)</code>方法来计算并返回最终结果。</p><p>下图演示了聚合过程：</p><p><img loading="lazy" alt="img.png" src="/assets/images/aggregate-function-3935a933c2c2c5f9f8b720595b0eb5ff.png" width="505" height="317" class="img_ev3q"></p><p>在本例中，我们假设有一个包含饮料数据的表。该表由三列<code>(id、name、price)</code>和5行数据组成。我们想找出表中所有饮料的最高价格，即执行max()聚合。我们需要计算这5行中的每一行。结果是一个标量数值。</p><p>为了定义聚合函数，必须扩展<code>org.apache.flink.table.functions</code>中的基类<code>AggregateFunction</code>，并实现一个或多个名为<code>accumulate(...)</code>的求值方法。
<code>accumulate</code>方法必须<strong>public</strong>，而不是静态的。<code>accumulate</code>方法可以重载。</p><p>默认使用反射自动提取输入、累加器和输出数据类型，包括累加器泛型ACC和返回结果泛型T。输入参数来自一个或多个<code>accumulate(...)</code>方法。</p><p>下面的示例演示如何定义自己的聚合函数并在查询中调用它。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">    import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.AggregateFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import static org.apache.flink.table.api.Expressions.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 自定义聚合函数的可变累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class WeightedAvgAccumulator {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public long sum = 0;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public int count = 0;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 第一个泛型表示聚合结果类型，也就是返回值类型，第二个泛型表示累加器类型</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class WeightedAvg extends AggregateFunction&lt;Long, WeightedAvgAccumulator&gt; {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 创建并初始化累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 累加器是计算中间结果的数据结构体，存储聚合数据值，直到计算最终聚合结果。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @return 具有初始化值的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public WeightedAvgAccumulator createAccumulator() {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return new WeightedAvgAccumulator();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 计算并返回最终结果</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Long getValue(WeightedAvgAccumulator acc) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (acc.count == 0) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            return acc.sum / acc.count;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 处理输入参数值，并且更新提供的累加器实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 这个方法可以被重载。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 自定义聚合函数必须有至少一个accumulate()方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param acc 包含当前聚合结果的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param iValue 用户输入参数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param iWeight 用户输入参数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void accumulate(WeightedAvgAccumulator acc, Long iValue, Integer iWeight) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.sum += iValue * iWeight;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.count += iWeight;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 从累加器实例撤回输入值。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 当前设计假定该输入值是以前累加过的值。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 该方法可以被重载。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 在无界表上使用有界OVER聚合数据时，必须实现该方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param acc 包含当前聚合结果的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param iValue 用户输入参数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param iWeight 用户输入参数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void retract(WeightedAvgAccumulator acc, Long iValue, Integer iWeight) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.sum -= iValue * iWeight;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.count -= iWeight;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 将一组累加器实例聚合到一个累加器实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 在无界会话窗口、滑动窗口进行分组聚合，以及在有界分区聚合时必须实现该方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 除此之外，实现该方法对优化器是有帮助的。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 比如，两阶段聚合优化要求所有聚合函数支持“merge”方法</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param acc 保存聚合结果的累加器。注意，它应该包含之前聚合的结果，因此，我们不能在聚合方法中替换或清理这个实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param it 一组将被合并的累加器对应的迭代器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void merge(WeightedAvgAccumulator acc, Iterable&lt;WeightedAvgAccumulator&gt; it) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        for (WeightedAvgAccumulator a : it) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.count += a.count;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.sum += a.sum;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 重置累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void resetAccumulator(WeightedAvgAccumulator acc) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.count = 0;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.sum = 0L;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class useFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中调用未被注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .groupBy($(&quot;myField&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), call(WeightedAvg.class, $(&quot;value&quot;), $(&quot;weight&quot;)));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 注册函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.createTemporarySystemFunction(&quot;WeightedAvg&quot;, WeightedAvg.class);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中调用注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .groupBy($(&quot;myField&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), call(&quot;WeightedAvg&quot;, $(&quot;value&quot;), $(&quot;weight&quot;)));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在SQL中调用注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.sqlQuery(</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                &quot;SELECT myField, WeightedAvg(`value`, weight) FROM MyTable GROUP BY myField&quot;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>WeightedAvg类的<code>accumulate(...)</code>方法接受三个输入参数。第一个是累加器，另外两个是用户自定义的输入。为了计算加权平均值，累加器需要存储已累积的所有数据的加权和计数。
在我们的示例中，我们定义了一个类WeightedAvgAccumulator作为累加器。累加器由Flink的checkpoint机制自动管理，并在出现错误时恢复，以确保恰好一次语义。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="必选和可选方法">必选和可选方法<a class="hash-link" href="#必选和可选方法" title="Direct link to heading">​</a></h3><p>对于每个自定义AggregateFunction函数，以下方法是必须实现的：</p><ul><li>createAccumulator()</li><li>accumulate(...)</li><li>getValue(...)</li></ul><p>此外，还有一些可选的方法可以实现。虽然其中一些方法只是为了让系统更有效地执行查询，但在某些情况下则必需实现的。
例如，如果在<code>会话分组窗口（session group window）</code>上调用聚合函数，则<strong>merge(...)</strong>方法是强制性的(当“连接”两个会话窗口的数据行时，需要连接两个会话窗口的累加器)。</p><p>AggregateFunction的以下方法实现取决于使用情境：</p><ul><li>retract(...)：在OVER窗口上进行聚合时需要使用。</li><li>merge(...)：对于许多有界聚合、会话窗口和滑动窗口聚合都是必需的。此外，该方法也有助于查询优化。例如，两阶段聚合优化要求所有AggregateFunction支持merge方法。
两阶段聚合：类似于MR中的combiner，先在map端进行小的聚合，最后在reduce端再次聚合。</li></ul><p>如果聚合函数只能在OVER窗口中使用，则可以通过返回<code>FunctionRequirement</code>来声明。在<code>getRequirements()</code>中返回<code>FunctionRequirement.OVER_WINDOW_ONLY</code>。
如果累加器需要存储大量的数据，则使用<code>org.apache.flink.table.api.dataview.ListView</code>和<code>org.apache.flink.table.api.dataview.MapView</code>
提供的高级特性，在无界数据场景中利用Flink的状态后端。有关这个高级特性的更多信息，请参阅相应类的文档。</p><p>由于有些方法是可选的，或者是可以重载，所以运行时是通过生成的代码来调用聚合函数方法的。这意味着基类并不总是提供具体方法实现需要覆盖的签名。然而，所有提到的方法都必须公开的，而且不是静态的，并且完全按照上面提到的方法的名字命名。</p><p>下面给出未在AggregateFunction中声明并由生成的代码调用的所有方法的详细文档。</p><p><strong>accumulate(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 处理输入参数值，并且更新提供的累加器实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 这个方法可以被重载。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 自定义聚合函数必须有至少一个accumulate()方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param acc 包含当前聚合结果的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param: [user defined inputs] 输入值（通常是新到达数据行字段）</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> **/</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void accumulate(ACC accumulator,[user defined inputs])</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>retract(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 从累加器实例撤回输入值。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 当前设计假定该输入值是以前累加过的值。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 该方法可以被重载。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 在无界表上使用有界OVER聚合数据时，必须实现该方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param accumulator 包含当前聚合结果的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param [user defined inputs] 输入值（通常是新到达数据行字段）</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void retract(ACC accumulator,[user defined inputs])</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>merge(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 将一组累加器实例聚合到一个累加器实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 在无界会话窗口、滑动窗口进行分组聚合，以及在有界分区聚合时必须实现该方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 除此之外，实现该方法对优化器是有帮助的。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 比如，两阶段聚合优化要求所有聚合函数支持“merge”方法</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param accumulator 保存聚合结果的累加器。注意，它应该包含之前聚合的结果，因此，我们不能在聚合方法中替换或清理这个实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param iterable 一组将被合并的累加器对应的迭代器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void merge(ACC accumulator,java.lang.Iterable&lt;ACC&gt; iterable)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="表聚合函数">表聚合函数<a class="hash-link" href="#表聚合函数" title="Direct link to heading">​</a></h2><p>用户定义的表聚合函数(UDTAGG)可以将多行标量值映射为0、1或多行(或结构化类型)标量值。返回的记录可以由一个或多个字段组成。如果输出记录只包含一个字段，则可以省略结构化，并且发出一个标量值，该标量值将由运行时隐式包装到row中。</p><p>与聚合函数类似，表聚合的行为以累加器的概念为中心。累加器是中间数据结构，用于存储聚合值，直到计算出最终聚合结果。</p><p>对于每一组需要聚合的行，运行时将通过调用<code>createAccumulator()</code>创建一个空的累加器。随后，对每个输入行调用函数的<code>accumulate(...)</code>方法来更新累加器。
处理完所有行后，调用函数的<code>emitValue(...)</code>或<code>emitUpdateWithRetract(...)</code>方法来计算并返回最终结果。</p><p>下图演示了聚合过程：</p><p><img loading="lazy" alt="img.png" src="/assets/images/table-aggregate-function-4477e8c5be7d6733073ad9610e2ad4f6.png" width="530" height="270" class="img_ev3q"></p><p>在本例中，我们假设一个包含饮料数据的表。该表由三列<code>(id、name、price)</code>和5行数据组成。我们想在表格中找出所有饮料最高的2个价格，即执行TOP2()表格汇总。我们需要计算这5行中的每一行。结果是一个包含前2个值的表。</p><p>为了定义表聚合函数，必须扩展<code>org.apache.flink.table.functions</code>中的基类<strong>TableAggregateFunction</strong>，并实现一个或多个名为<code>accumulate(...)</code>的求值方法。
<code>accumulate</code>方法必须<strong>public</strong>，而且是非静态的。累加方法也可以通过实现多个名为<code>accumulate</code>的方法来重载。</p><p>默认情况下，使用反射自动提取输入、累加器和输出数据类型。这包括确定累加器泛型参数ACC和累加器结果泛型参数T。输入参数来自一个或多个<code>accumulate(...)</code>方法。</p><p>如果打算在Python中实现或调用函数，请参阅Python函数文档了解更多细节。</p><p>下面的示例演示如何定义自己的表聚合函数并在查询中调用它。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.api.java.tuple.Tuple2;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.api.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.TableAggregateFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.util.Collector;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import static org.apache.flink.table.api.Expressions.*;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 自定义表聚合函数的可变累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class Top2Accumulator {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer first;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer second;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 函数包含用户输入值（INT），保存中间结果到Top2Accumulator对象，最后返回Tuple2&lt;Integer, Integer&gt;类型的结果，第一个表示结果值，第二个表示级别。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 函数第一个泛型表示聚合结果类型，第二个泛型表示累加器类型</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class Top2 extends TableAggregateFunction&lt;Tuple2&lt;Integer, Integer&gt;, Top2Accumulator&gt; {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 创建一个初始化的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @return 初始化的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Top2Accumulator createAccumulator() {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        Top2Accumulator acc = new Top2Accumulator();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.first = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.second = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return acc;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 处理输入值，并且更新之前的累加器实例。这个方法可以被重载。表聚合函数要求至少一个accumulate()方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param acc 包含当前聚合结果的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param value 输入值（通常是用户输入的数据）</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void accumulate(Top2Accumulator acc, Integer value) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (value &gt; acc.first) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.second = acc.first;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.first = value;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        } else if (value &gt; acc.second) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.second = value;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 合并一组累加器实例到一个累加器实例。这个方法必须在无界会话、滑动窗口分组聚合、有界分组聚合中实现。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param acc 将要保存聚合结果的累加器。这个累加器可能包含之前聚合的结果，因此用户不能替换，或者是清理这个实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param it 将要被合并的一组累加器对应的迭代器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void merge(Top2Accumulator acc, Iterable&lt;Top2Accumulator&gt; it) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        for (Top2Accumulator otherAcc : it) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            accumulate(acc, otherAcc.first);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            accumulate(acc, otherAcc.second);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * 每次聚合结果应该被物化时调用。返回值可以是早期未完成的结果（当数据到达时定期发出），或者是最终的聚合结果。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param acc 包含当前聚合结果的累加器。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     * @param out 输出数据的收集器。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void emitValue(Top2Accumulator acc, Collector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // emit the value and rank</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (acc.first != Integer.MIN_VALUE) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            out.collect(Tuple2.of(acc.first, 1));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (acc.second != Integer.MIN_VALUE) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            out.collect(Tuple2.of(acc.second, 2));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">class UseFun {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        EnvironmentSettings settings = EnvironmentSettings.newInstance().inStreamingMode().build();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        TableEnvironment env = TableEnvironment.create(settings);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中通过内联方式调用未被注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .groupBy($(&quot;myField&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .flatAggregate(call(Top2.class, $(&quot;value&quot;)))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;f0&quot;), $(&quot;f1&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 在Table API中通过内联方式调用未被注册的函数，并且使用别名来更好的标识返回值二元组的属性</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .groupBy($(&quot;myField&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .flatAggregate(call(Top2.class, $(&quot;value&quot;)).as(&quot;value&quot;, &quot;rank&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;value&quot;), $(&quot;rank&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 注册函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env.createTemporarySystemFunction(&quot;Top2&quot;, Top2.class);</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        //在Table API中调用注册的函数</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        env</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .from(&quot;MyTable&quot;)</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .groupBy($(&quot;myField&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .flatAggregate(call(&quot;Top2&quot;, $(&quot;value&quot;)).as(&quot;value&quot;, &quot;rank&quot;))</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                .select($(&quot;myField&quot;), $(&quot;value&quot;), $(&quot;rank&quot;));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Top2类的<code>accumulate(...)</code>方法接受两个输入。第一个是累加器，第二个是用户定义的输入。
为了计算结果，累加器需要存储已累积的所有数据的2个最高值。累加器由Flink的checkpoint机制自动管理，并在出现错误时恢复，以确保精确一次的语义。结果值与排名索引作为结果一起发出。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="必选和可选方法-1">必选和可选方法<a class="hash-link" href="#必选和可选方法-1" title="Direct link to heading">​</a></h3><p>对于每个自定义<code>TableAggregateFunction</code>，以下方法是必须的：</p><ul><li>createAccumulator()</li><li>accumulate(...)</li><li>emitValue(...) or emitUpdateWithRetract(...)</li></ul><p>此外，还有一些可选的方法可以实现。其中一些方法可以让系统更有效地执行查询，但在某些情境下，有些方法是必需的。</p><p>例如，如果在会话分组窗口<code>（session group window）</code>上使用表聚合函数，则<code>merge(...)</code>方法是强制性的(当需要“连接”两个会话窗口的数据行时，需要连接两个会话窗口的累加器)。</p><p><code>TableAggregateFunction</code>的以下方法取决于用例:</p><ul><li>retract(...)：在OVER窗口上进行聚合时需要使用。</li><li>merge(...)：对于许多有界聚合、无界会话、滑动窗口聚合都是必需的。</li><li>emitValue(...)：对于有界、窗口聚合是必需的。</li></ul><p>TableAggregateFunction的以下方法可以提高流作业的性能：</p><ul><li>emitUpdateWithRetract(...)：用于发出在回撤模式下更新的值。</li></ul><p><code>emitValue(...)</code>方法总是通过累加器发出完整的数据。在无界流场景中可能会带来性能问题。
以Top N函数为例，每次<code>emitValue(...)</code>都会发出所有N个值。为了提高性能，可以实现<code>emitUpdateWithRetract(...)</code>，在<code>retract</code>模式下增量输出数据。
换句话说，一旦有了更新，该方法可以在发送新的、更新的记录之前撤销旧记录。该方法将优先于<code>emitValue(...)</code>方法调用。</p><p>如果表聚合函数只能在OVER窗口中应用，则可以通过<code>getRequirements()</code>方法返回<code>FunctionRequirement.OVER_WINDOW_ONLY</code>来说明。</p><p>如果一个累加器需要存储大量的数据，可以使用<code>org.apache.flink.table.api.dataview.ListView</code>和<code>org.apache.flink.table.api.dataview.MapView</code>
提供的高级特性，在无界流数据场景中利用Flink的状态后端。有关这个高级特性的更多信息，请参阅相应类的文档。</p><p>由于有些方法是可选或可以重载的，因此flink会根据生成的代码来调用这些方法。基类并不总是提供所有需要实现的方法的签名。然而，所有提到的方法都必须是public，非静态的，并且完全按照上面提到的名字命名。</p><p>下面给出了未在TableAggregateFunction中声明并由生成的代码调用的所有方法的详细文档。</p><p><strong>accumulate(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 处理输入参数值，并且更新提供的累加器实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 这个方法可以被重载。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 自定义聚合函数必须有至少一个accumulate()方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param acc 包含当前聚合结果的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param: [user defined inputs] 输入值（通常是新到达数据行字段）</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> **/</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void accumulate(ACC accumulator,[user defined inputs])</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>retract(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 从累加器实例撤回输入值。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 当前设计假定该输入值是以前累加过的值。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 该方法可以被重载。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 在无界表上使用有界OVER聚合数据时，必须实现该方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param accumulator 包含当前聚合结果的累加器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param [user defined inputs] 输入值（通常是新到达数据行字段）</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void retract(ACC accumulator,[user defined inputs])</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>merge(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 将一组累加器实例聚合到一个累加器实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 在无界会话窗口、滑动窗口进行分组聚合，以及在有界分区聚合时必须实现该方法。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 除此之外，实现该方法对优化器是有帮助的。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 比如，两阶段聚合优化要求所有聚合函数支持“merge”方法</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param accumulator 保存聚合结果的累加器。注意，它应该包含之前聚合的结果，因此，我们不能在聚合方法中替换或清理这个实例。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * @param iterable 一组将被合并的累加器对应的迭代器</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void merge(ACC accumulator,java.lang.Iterable&lt;ACC&gt; iterable)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>emitValue(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 每次聚合结果应该被物化时调用。返回值可以是早期未完成的结果（当数据到达时定期发出），或者是最终的聚合结果。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * param: accumulator 包含当前聚合结果的累加器。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * param: out 输出数据的收集器。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void emitValue(ACC accumulator,org.apache.flink.util.Collector&lt;T&gt; out)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>emitUpdateWithRetract(...)：</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 每次聚合结果应该被物化时调用。返回值可以是早期未完成的结果（当数据到达时定期发出），或者是最终的聚合结果。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 与emitValue()相比，emitUpdateWithRetract() 用来发出被更新的结果值。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 这个方法在回撤模式（也叫做&quot;update before&quot; 和 &quot;update after&quot;）下会立即输出数据。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 一旦遇到一个更新，我们必须在发送新的更新数据之前撤回旧的记录。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 如果在表聚合函数中同时实现了emitUpdateWithRetract()和emitValue()，则会优先使用emitUpdateWithRetract()，</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * 因为这个方法可以以增长的方式输出数据，比emitValue更有效。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * param: accumulator 包含当前聚合结果的累加器。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> * param: out 回撤收集器被用于输出数据。使用collect()方法输出增加的数据，使用retract()方法删除数据。</span><br></span><span class="token-line" style="color:#000000"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public void emitUpdateWithRetract(ACC accumulator,RetractableCollector&lt;T&gt; out)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="retraction案例">Retraction案例<a class="hash-link" href="#retraction案例" title="Direct link to heading">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.api.java.tuple.Tuple2;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">import org.apache.flink.table.functions.TableAggregateFunction;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">// 前两个属性表示最新的top2，后两个属性表示上一次top2</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class Top2WithRetractAccumulator {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer first;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer second;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer oldFirst;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Integer oldSecond;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">}</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">public class Top2WithRetract extends TableAggregateFunction&lt;Tuple2&lt;Integer, Integer&gt;, Top2WithRetractAccumulator&gt; {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public Top2WithRetractAccumulator createAccumulator() {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        Top2WithRetractAccumulator acc = new Top2WithRetractAccumulator();</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.first = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.second = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.oldFirst = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        acc.oldSecond = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        return acc;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void accumulate(Top2WithRetractAccumulator acc, Integer v) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        // 更新最新top2数据</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (v &gt; acc.first) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.second = acc.first;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.first = v;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        } else if (v &gt; acc.second) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.second = v;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    public void emitUpdateWithRetract(Top2WithRetractAccumulator acc, RetractableCollector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (!acc.first.equals(acc.oldFirst)) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            // 如果发现有更新数据，则先删除之前的旧值，然后发出新值</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            if (acc.oldFirst != Integer.MIN_VALUE) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                out.retract(Tuple2.of(acc.oldFirst, 1));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            out.collect(Tuple2.of(acc.first, 1));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.oldFirst = acc.first;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        if (!acc.second.equals(acc.oldSecond)) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            // 如果发现有更新数据，则先删除之前的旧值，然后发出新值</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            if (acc.oldSecond != Integer.MIN_VALUE) {</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">                out.retract(Tuple2.of(acc.oldSecond, 2));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            out.collect(Tuple2.of(acc.second, 2));</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">            acc.oldSecond = acc.second;</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#000000"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/apache/incubator-streampark-website/edit/dev/docs/flinksql/udf/2-udf.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/flinksql/udf/1-introduce"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Introduction</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/flinksql/format/1-introduce"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Introduction</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概述" class="table-of-contents__link toc-highlight">概述</a></li><li><a href="#实现步骤" class="table-of-contents__link toc-highlight">实现步骤</a><ul><li><a href="#函数类" class="table-of-contents__link toc-highlight">函数类</a></li><li><a href="#evaluation方法" class="table-of-contents__link toc-highlight">evaluation方法</a></li><li><a href="#类型推断" class="table-of-contents__link toc-highlight">类型推断</a></li><li><a href="#自定义类型推断" class="table-of-contents__link toc-highlight">自定义类型推断</a></li><li><a href="#确定性结果" class="table-of-contents__link toc-highlight">确定性结果</a></li><li><a href="#运行时集成方法" class="table-of-contents__link toc-highlight">运行时集成方法</a></li></ul></li><li><a href="#标量函数" class="table-of-contents__link toc-highlight">标量函数</a></li><li><a href="#表函数" class="table-of-contents__link toc-highlight">表函数</a></li><li><a href="#聚合函数" class="table-of-contents__link toc-highlight">聚合函数</a><ul><li><a href="#必选和可选方法" class="table-of-contents__link toc-highlight">必选和可选方法</a></li></ul></li><li><a href="#表聚合函数" class="table-of-contents__link toc-highlight">表聚合函数</a><ul><li><a href="#必选和可选方法-1" class="table-of-contents__link toc-highlight">必选和可选方法</a></li><li><a href="#retraction案例" class="table-of-contents__link toc-highlight">Retraction案例</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item">
                  <div class="footer-left-box">
                    <div class="flex align-center footer-system">
                      <span class="system-title">About StreamPark</span>
                    </div>
                    <p>Make stream processing easier! easy-to-use streaming application development framework and operation platform</p>
                  </div>
                </li></ul></div><div class="col footer__col"><div class="footer__title">Resource</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Document</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-streampark/releases" target="_blank" rel="noopener noreferrer" class="footer__link-item">Releases<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-streampark/issues/507" target="_blank" rel="noopener noreferrer" class="footer__link-item">FAQ<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/apache/incubator-streampark" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-streampark/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">Issue Tracker<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-streampark/pulls" target="_blank" rel="noopener noreferrer" class="footer__link-item">Pull Requests<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Follow</div><ul class="footer__items clean-list"><li class="footer__item">
                <div class="subscribe-box">
                    <div class="d-flex align-items-center" style="margin-bottom: 30px;padding-top: 11px">
                      <div class="subscribe-input flex-fill">
                        <input class="form-control" id="email_address" maxlength="60" name="email_address" placeholder="Subscribe with us">
                      </div>
                      <div class="subscribe-submit-inner">
                        <a class="btn btn-white m-0" type="submit" href="mailto:dev-subscribe@streampark.apache.org">
                          <span><i class="fa fa-paper-plane text-white"></i></span>
                        </a>
                      </div>
                    </div>
                    <ul class="icon-bottom">
                        <li>
                          <a href="javascript:void(0)">
                            <i class="fa fa-wechat"></i>
                            <div class="wechat-dropdown"><img src="/image/join_wechat.png" alt="weChat"></div>
                          </a>
                        </li>
                        <li><a href="javascript:void(0)"><i class="fa fa-twitter"></i></a></li>
                        <li><a href="javascript:void(0)"><i class="fa fa-slack"></i></a></li>
                        <li><a href="javascript:void(0)"><i class="fa fa-facebook"></i></a></li>
                    </ul>
                </div>
              </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">
            <div style="text-align: left;margin-top:30px">
                <div class="d-flex align-items-center">
                    <div>
                      <a href="https://incubator.apache.org/" class="footerLogoLink" one-link-mark="yes">
                        <img src="/image/apache-incubator.svg" alt="Apache Incubator logo" class="footer__logo">
                      </a>
                    </div>
                    <div>
                      <p style="font-family: Avenir-Medium;font-size: 14px;color: #999;line-height: 25px;">
                      Apache StreamPark is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.
                      </p>
                  </div>
                </div>
                
                <div style="border-top: 1px solid #525252;min-height: 60px;line-height: 25px;text-align: left;font-family: Avenir-Medium;font-size: 14px;color: #999;display: flex;align-items: center;">
                  <span>
                      Copyright © 2022 The Apache Software Foundation. Apache StreamPark, StreamPark, and its feather logo are trademarks of The Apache Software Foundation.
                  </span>
                </div>
            </div></div></div></div></footer></div>
<script src="/assets/js/runtime~main.cdf548bd.js"></script>
<script src="/assets/js/main.d2f28e18.js"></script>
</body>
</html>